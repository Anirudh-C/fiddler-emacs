* fiddler-emacs
** Setup =package.el=
Load =package.el=
#+BEGIN_SRC emacs-lisp
(require 'package)
#+END_SRC
Add common package archives
#+BEGIN_SRC emacs-lisp
(add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
(add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
(add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/"))
#+END_SRC
Ensure that packages aren't loaded again after processing the init file
#+BEGIN_SRC emacs-lisp
(setq package-enable-at-startup nil)
#+END_SRC
Initialize the package installation
#+BEGIN_SRC emacs-lisp
(package-initialize)
#+END_SRC
Customize puts a lot of stuff into my =init.el=
#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file)
#+END_SRC
** Configure =use-package=
Install =use-package= if not installed
#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
#+END_SRC
Load =use-package= while compiling
#+BEGIN_SRC emacs-lisp
(eval-when-compile
  (require 'use-package))
#+END_SRC
** Tell Emacs who I am
#+BEGIN_SRC emacs-lisp
(setq user-full-name "Anirudh C"
      user-mail-address "anirudh.c@iiitb.org")
#+END_SRC
** Cosmetics
I don't like the default startup area message
#+BEGIN_SRC emacs-lisp
(defun display-startup-echo-area-message ()
  (message "Welcome to Fiddler-Emacs"))
#+END_SRC
Show line numbers
#+BEGIN_SRC emacs-lisp
  (add-hook 'find-file-hook 'linum-mode)
#+END_SRC
*** Theme
I need emacs to look exactly like I want it to, so
start by removing the default startup buffer
#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t
      inhibit-startup-message t
      inhibit-startup-echo-area-message t)
#+END_SRC
Also remove the scrollbar, menubar and toolbar
#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(when (boundp 'scroll-bar-mode)
  (scroll-bar-mode -1))
#+END_SRC 
When I use emacs I deal with a lot of parentheses, I want emacs
to match them for me and do it colourfully using =rainbow-delimiters=
#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
(use-package rainbow-delimiters
  :ensure t
  :init
  (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
#+END_SRC
I also use tabs(size 4) in emacs but I don't want TeX to get confused
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
(setq tab-width 4)
#+END_SRC
I also don't want emacs telling me I'm opening a large file
#+BEGIN_SRC emacs-lisp
(setq large-file-warning-threshold nil)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(setq custom-safe-themes t)
#+END_SRC
I also want emacs to tell me which column I am in the buffer
#+BEGIN_SRC emacs-lisp
(column-number-mode t)
#+END_SRC
I don't like trailing whitespaces as it messes so many things up
#+BEGIN_SRC emacs-lisp
(defun fiddler/buf-show-trailing-whitespace ()
  (interactive)
    (setq show-trailing-whitespace t))
(add-hook 'prog-mode-hook 'fiddler/buf-show-trailing-whitespace)
#+END_SRC 
Now for the major cosmetic changes. Use =kaolin-themes= and ~kaolin-aurora~
#+BEGIN_SRC emacs-lisp
  (use-package kaolin-themes
    :ensure t
    :config
    (load-theme 'kaolin-aurora t))
#+END_SRC
*** Modeline
#+BEGIN_SRC emacs-lisp
  (use-package doom-modeline
    :ensure t
    :defer t
    :hook (after-init . doom-modeline-init)
    :config
    (setq doom-modeline-bar-width 3
          doom-modeline-buffer-file-name-style 'truncate-with-project
          doom-modeline-minor-modes nil))
#+END_SRC
*** Daemon Colors Fix
Custom init functions
#+BEGIN_SRC emacs-lisp
(defun fiddler/init-theme (&optional frame)
  "Initiate the theme given an optional frame argument"
  (load-theme 'kaolin-aurora t)
  (doom-modeline-init)
  (message "Welcome to Fiddler-Emacs"))

(defun fiddler/reload-theme-in-daemon (frame)
  "Force the theme on the running frame (created via the daemon)"
  (when (or (daemonp) (not (display-graphic-p)))
    (with-selected-frame frame
      (run-with-timer 0.1 nil #'fiddler/init-theme))))
#+END_SRC
Run functions after creating a new frame
#+BEGIN_SRC emacs-lisp
(add-hook 'after-make-frame-functions #'fiddler/init-theme)
(add-hook 'after-make-frame-functions #'fiddler/reload-theme-in-daemon)
#+END_SRC
Initiate theme in GUI
#+BEGIN_SRC emacs-lisp
(fiddler/init-theme)
#+END_SRC
** User Interface
i3 uses Alt as a modifier
#+BEGIN_SRC emacs-lisp
(setq x-super-keysym 'meta)
#+END_SRC
Would be fun to =try= out packages
#+BEGIN_SRC emacs-lisp
  (use-package try
    :ensure t)
#+END_SRC
Also I need to be able to edit my config in emacs and =restart-emacs=
in emacs
#+BEGIN_SRC emacs-lisp
(use-package restart-emacs
  :ensure t)
#+END_SRC
Make a sratch buffer from thin air
#+BEGIN_SRC emacs-lisp
(defun fiddler/gen-scratch ()
  "Create and switch to a temporary scratch buffer with a random name."
  (interactive)
  (switch-to-buffer (make-temp-name "scratch-")))
#+END_SRC
Enable buffer narrowing
#+BEGIN_SRC emacs-lisp
  (put 'narrow-to-defun 'disabled nil)
  (put 'narrow-to-page 'disabled nil)
  (put 'narrow-to-region 'disabled nil)
#+END_SRC
Renaming files becomes easier
#+BEGIN_SRC emacs-lisp
(defun fiddler/rename-file-and-buffer (new-name)
  "Renames both current buffer and file it's visiting to NEW-NAME."
  (interactive "FNew name: ")
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not filename)
        (message "Buffer '%s' is not visiting a file!" name)
      (if (get-buffer new-name)
          (message "A buffer named '%s' already exists!" new-name)
        (progn
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil))))))
#+END_SRC
Edit a file in sudo on the fly
#+BEGIN_SRC emacs-lisp
  (defun fiddler/find-file-sudo ()
    "Find file as root if necessary."
    (interactive)
    (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name)))
#+END_SRC
Binding for buffer sequential navigation
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-l") 'next-buffer)
  (global-set-key (kbd "C-x C-h") 'next-buffer)
#+END_SRC
Undoing and redoing using =undo-tree= only
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :config
    (global-undo-tree-mode))
#+END_SRC
Make redo the redo of undo-tree
#+BEGIN_SRC emacs-lisp
(defalias 'redo 'undo-tree-redo)
#+END_SRC
*** Projects
**** Git
I use git to manage my projects and =magit= provides the interface
and =projectile= is for project specific functionality
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t)
  (global-set-key (kbd "C-x g") 'magit)
  ;; I need to search for files in a project
  (use-package projectile
    :ensure t
    :config
    (projectile-mode)
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
    (setq projectile-completion-system 'ivy))
#+END_SRC
I also don't need backup and autosave files because I use git
#+BEGIN_SRC emacs-lisp
(setq make-backup-files nil
      auto-save-default nil)
#+END_SRC
**** Make a New Project
#+BEGIN_SRC emacs-lisp
  (defun fiddler/make-project ()
    (interactive)
    (magit-status (read-directory-name "Directory:")))
#+END_SRC
*** Completion
Use =ivy= for completion
#+BEGIN_SRC emacs-lisp
(use-package ivy 
  :ensure t
  :diminish (ivy-mode . "")
  :config
  (ivy-mode 1)
  ;; add ‘recentf-mode’ and bookmarks to ‘ivy-switch-buffer’.
  (setq ivy-use-virtual-buffers t)
  ;; number of result lines to display
  (setq ivy-height 10)
  ;; does not count candidates
  (setq ivy-count-format "")
  ;; no regexp by default
  (setq ivy-initial-inputs-alist nil)
  ;; configure regexp engine.
  (setq ivy-re-builders-alist
	;; allow input not in order
        '((t   . ivy--regex-ignore-order))))
#+END_SRC
Ensure fuzzy search happens using =flx=
#+BEGIN_SRC emacs-lisp
  (use-package flx
    :ensure t)
#+END_SRC
Setup =counsel= for additional completion
#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :after ivy
    :ensure t
    :config
    (counsel-mode)
    (global-set-key (kbd "M-x") 'counsel-M-x)
    (global-set-key (kbd "C-x C-f") 'counsel-find-file)
    (global-set-key (kbd "C-x s") 'counsel-git-grep))
#+END_SRC
Make the buffer listing more complete using =ivy-rich=
#+BEGIN_SRC emacs-lisp
  (use-package ivy-rich
    :ensure t
    :after ivy
    :config
    (ivy-rich-mode))
#+END_SRC
Setup =swiper= for search
#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :ensure t
    :after ivy
    :bind (("C-s" . swiper)
           ("C-r" . swiper)))
#+END_SRC
*** Ranger
Use =ranger= like behaviour in dired
#+BEGIN_SRC emacs-lisp
  (use-package ranger
    :ensure t
    :config
    (ranger-override-dired-mode t))
#+END_SRC
*** Multiple Cursors
Use =multiple-cursors= behaviour
#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :ensure t
    :config
    (global-set-key (kbd "C->") 'mc/mark-next-like-this)
    (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
    (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this))
#+END_SRC
*** Easy Killing
Use =easy-kill= instead of =kill-ring-save=
#+BEGIN_SRC emacs-lisp
  (use-package easy-kill
    :ensure t
    :config
    (global-set-key [remap kill-ring-save] 'easy-kill)
    (global-set-key [remap mark-sexp] 'easy-mark))
#+END_SRC
Browse the kill-ring easily using =browse-kill-ring=
#+BEGIN_SRC emacs-lisp
  (use-package browse-kill-ring
    :ensure t)
#+END_SRC
*** Window Management
Use =ace-window= to manage windows
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :ensure t
    :config
    (global-set-key (kbd "M-o") 'ace-window)
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    (setq aw-background nil))
#+END_SRC
** Environments
*** Markdown
Highlighting using =markdown-mode=
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :commands (markdown-mode gfm-mode)
  ;; Tell emacs to use different modes for different types of markdown files,
  ;; that is, use github flavoured markdown for my READMEs and normal markdown everywhere else.
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init (setq markdown-command "multimarkdown"))
#+END_SRC
*** Web
Install some dependencies (=rainbow-mode= for colors, =css-mode= for css highlighting)
#+BEGIN_SRC emacs-lisp
;; Understand css
(use-package rainbow-mode
  :ensure t)
(use-package css-mode
  :ensure t
  :config
  ;; hook to get colors in css
  (add-hook 'css-mode-hook (lambda ()
(rainbow-mode))))
#+END_SRC
Install =web-mode= and =emmet-mode=
#+BEGIN_SRC emacs-lisp
  (use-package emmet-mode
    :ensure t
    :commands emmet-mode)

  (use-package web-mode
    :ensure t
    :defer t
    :config
    ;; Indent all my web mode code by 2 instead of 4
    (setq web-mode-attr-indent-offset 2)
    (setq web-mode-code-indent-offset 2)
    (setq web-mode-css-indent-offset 2)
    (setq web-mode-indent-style 2)
    (setq web-mode-markup-indent-offset 2)
    (setq web-mode-sql-indent-offset 2)
    ;; Highlight columns
    (setq web-mode-enable-current-column-highlight t)
    (setq web-mode-enable-current-element-highlight t))
#+END_SRC
Load =web-mode= in the specific files
#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.css?\\'" . web-mode))
#+END_SRC
Add completion vocabulary to css and html when in =web-mode=
#+BEGIN_SRC emacs-lisp
  (use-package company-web
    :ensure t
    :after company
    :config
    (add-hook 'web-mode-hook (lambda ()
                               (set (make-local-variable 'company-backends) '(company-css company-web-html company-files)))))
#+END_SRC
Enable =emmet-mode= in =web-mode=
#+BEGIN_SRC emacs-lisp
  (add-hook 'web-mode-hook 'emmet-mode)
#+END_SRC
For =emmet-mode= to switch between html and css in the same document
#+BEGIN_SRC emacs-lisp
  (add-hook 'web-mode-before-auto-complete-hooks
            '(lambda ()
               (let ((web-mode-cur-lang
                      (web-mode-language-at-pos)))
                 (if (string= web-mode-cur-lang "css")
                     (setq emmet-use-css-transform t)
                   (setq emmet-use-css-transform nil)))))
#+END_SRC
Setup =impatient-mode=
Dependencies (=simple-httpd= to start http server and =htmlize= for additional functionality)
#+BEGIN_SRC emacs-lisp
(use-package simple-httpd
  :ensure t)
(use-package htmlize
  :ensure t)
#+END_SRC
=impatient-mode=
#+BEGIN_SRC emacs-lisp
(use-package impatient-mode
  :ensure t)
#+END_SRC
**** Javascript
#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :ensure t)
#+END_SRC
Use =indium= in =js2-mode=
#+BEGIN_SRC emacs-lisp
  (use-package indium
    :ensure t
    :config
    (eval-when-compile
  (add-hook 'js-mode-hook #'indium-interaction-mode)))
#+END_SRC
Refactoring in =js2-mode=
#+BEGIN_SRC emacs-lisp
  (use-package js2-refactor
    :ensure t
    :defer t
    :config
    (add-hook 'js2-mode-hook #'js2-refactor-mode)
    (add-hook 'js-mode #'js2-refactor-mode)
  (js2r-add-keybindings-with-prefix "C-c C-m"))
#+END_SRC
Edit =json= nicely
#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :ensure t
    :defer t
    :config
  (setq js-indent-level 2))
#+END_SRC
=JSX= and =React=
#+BEGIN_SRC emacs-lisp
  (use-package rjsx-mode
    :ensure t
    :defer t
    :config
    (defun emmet/rjsx-mode-hook ()
      (setq-default emmet-expand-jsx-className? t)
      (emmet-mode))
    (add-hook 'rjsx-mode-hook 'emmet/rjsx-mode-hook)
  (setq-default rjsx-indent-level 2))
#+END_SRC
=elm-mode=
#+BEGIN_SRC emacs-lisp
(use-package elm-mode
  :ensure t
  :defer t
  :config
  (add-hook 'elm-mode-hook #'elm-oracle-setup-completion)
  (defun company/elm-mode-hook ()
    (add-to-list 'company-backends 'company-elm))
  (add-hook 'elm-mode-hook 'company/elm-mode-hook)
(custom-set-variables '(elm-format-on-save t)))
#+END_SRC
**** Rails
=projectile-rails= can help find files rails understands
#+BEGIN_SRC emacs-lisp
  (use-package projectile-rails
    :ensure t
    :config
    (projectile-rails-global-mode)
    (setq projectile-rails-keymap-prefix (kbd "C-c p C-r")))
#+END_SRC
*** Clojure
Install =clojure-mode=
#+BEGIN_SRC emacs-lisp
(use-package clojure-mode
  :ensure t)
#+END_SRC
Install =cider= for REPL interaction
#+BEGIN_SRC emacs-lisp
(use-package cider
  :ensure t)
#+END_SRC
*** PDF
Install and configure =pdf-tools=
#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :ensure t
  :config
  (pdf-tools-install)
  (setq-default pdf-view-display-size 'fit-width))
#+END_SRC
*** Speed Typing
Install =speed-type= to practice touch typing
#+BEGIN_SRC emacs-lisp
(use-package speed-type
  :ensure t)
#+END_SRC
*** Ebooks
Use =nov.el= to open ebooks
#+BEGIN_SRC emacs-lisp
  (use-package nov
    :ensure t
    :config
    (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode)))
#+END_SRC
*** EXWM
X window management using =exwm=
#+BEGIN_SRC emacs-lisp
  (use-package exwm
    :ensure t)
#+END_SRC
Utility function to eval at startup to start EXWM when necessary
#+BEGIN_SRC emacs-lisp
  (defun start-exwm ()
    (interactive)
    (require 'exwm-config)
    (exwm-config-default))
#+END_SRC
*** Python
Run the following =pip= install first
#+BEGIN_SRC sh
pip install --user jedi flake8 autopep8 yapf
#+END_SRC
Install =elpy=
#+BEGIN_SRC emacs-lisp
  (use-package elpy
    :ensure t
    :config
    (elpy-enable))
#+END_SRC
*** Lisp
Use =smartparens=
#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :config
    (require 'smartparens-config))
#+END_SRC
*** Drawing
Install =artist-mode=
#+BEGIN_SRC emacs-lisp
  (require 'artist)
#+END_SRC
*** Pocket-reader
Use =pocket-reader.el= to read your pocket in emacs
#+BEGIN_SRC emacs-lisp
  (use-package pocket-reader
    :ensure t
    :config
    (add-hook 'pocket-reader-mode-hook (lambda ()
                                         "Disable line numbers in pocket reader"
                                         (line-number-mode -1))))
#+END_SRC
** Email
Install =mu4e=
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/mu4e")
(require 'mu4e)
#+END_SRC
Set the mail directory
#+BEGIN_SRC emacs-lisp
(setq mu4e-maildir (expand-file-name "~/email/outlook"))
#+END_SRC
Make eww open links
#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'eww-browse-url)
#+END_SRC
Add the sub directories
#+BEGIN_SRC emacs-lisp
(setq mu4e-drafts-folder "/DRAFTS")
(setq mu4e-sent-folder   "/SENT")
(setq mu4e-trash-folder  "/DELETED")
(setq message-signature-file "~/.emacs.d/.signature") ; put your signature in this file
#+END_SRC
Get the emails
#+BEGIN_SRC emacs-lisp
(setq mu4e-get-mail-command "mbsync -c ~/.emacs.d/.mbsyncrc uni"
      mu4e-html2text-command 'mu4e-shr2text
      mu4e-update-interval 120
      mu4e-headers-auto-update t)
#+END_SRC
Set some general settings
#+BEGIN_SRC emacs-lisp
(setq mu4e-date-format-long "%Y-%m-%d %H:%M:%S")
(setq mu4e-headers-date-format "%y%m%d %H:%M:%S")
(setq mu4e-reply-to-address "anirudh.c@iiitb.org"
    user-mail-address "anirudh.c@iiitb.org"
    user-full-name  "Anirudh C")

;; Images
(setq mu4e-show-images t)
(when (fboundp 'imagemagick-register-types)
  (imagemagick-register-types))
#+END_SRC
Sending Emails using =smtpmail= (SMTP)
#+BEGIN_SRC emacs-lisp
(require 'smtpmail)

; smtp
(setq message-send-mail-function 'smtpmail-send-it
      smtpmail-starttls-credentials
      '(("smtp.office365.com" 587 nil nil))
      smtpmail-default-smtp-server "smtp.office365.com"
      smtpmail-smtp-server "smtp.office365.com"
      smtpmail-smtp-service 587
      smtpmail-debug-info t)
#+END_SRC
Change the default reply quote string
#+BEGIN_SRC emacs-lisp
(setq message-citation-line-format "In response to the mail by %f on %a %d %b %Y at %R:\n")
(setq message-citation-line-function 'message-insert-formatted-citation-line)
#+END_SRC
Open mu4e when I press =C-c m=
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c m") 'mu4e)
#+END_SRC
** Org Mode
*** Display
How I want org-mode to look
#+BEGIN_SRC emacs-lisp
;; Tell emacs to start org mode in all .org files
(add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode))
;; Hide the leading stars and start org mode with indented structure
(setq org-hide-leading-stars t org-startup-indented t)
;; Use the nice down arrow to display folded content in org headlines
(setq org-ellipsis "⤵")
#+END_SRC
=org-bullets= need to look good
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :ensure t
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC
The emphasis markers in org mode aren't the *best*
#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers t)
#+END_SRC
*** Tasks and Org-Capture
**** Basic Setup
I have all my org files in a directory =~/org/= and I also have an index file which has all my TODOs in an outline and
I also have an archive file to archive my completed TODOs. I have a special file for my ideas which are basically TODOs without a deadline
#+BEGIN_SRC emacs-lisp
(setq org-directory "~/org")
#+END_SRC
I need a helper function to point to my orgfiles' absolute path using the relative path
#+BEGIN_SRC emacs-lisp
(defun org-file-path (filename)
  "Return the absolute address of an org file, given its relative name."
  (concat (file-name-as-directory org-directory) filename))
#+END_SRC
Now I can set my index file location and ideas file location
#+BEGIN_SRC emacs-lisp
(setq org-index-file (org-file-path "index.org"))
(setq org-idea-file (org-file-path "ideas.org"))
(setq org-projects-file (org-file-path "projects.org"))
#+END_SRC
I can also setup my archive file
#+BEGIN_SRC emacs-lisp
(setq org-archive-location
      (concat (org-file-path "archive.org") "::* From %s"))
#+END_SRC
I need org-agenda to tell me my TODOs from =index.org=
#+BEGIN_SRC emacs-lisp
(setq org-agenda-files (list org-index-file org-idea-file org-projects-file))
#+END_SRC
Save all org buffers when I quit agenda
#+BEGIN_SRC emacs-lisp
(add-hook 'org-agenda-mode-hook
          (lambda ()
            (add-hook 'auto-save-hook 'org-save-all-org-buffers nil t)
            (auto-save-mode)))
#+END_SRC
I want to archive my TODOs into =archive.org= when I finish them
#+BEGIN_SRC emacs-lisp
(defun done-and-dusted ()
  "Mark the state of an org-mode item as DONE and archive it."
  (interactive)
  (org-todo 'done)
  (org-archive-subtree))
#+END_SRC
I want to know when I did these tasks as well
#+BEGIN_SRC emacs-lisp
(setq org-log-done 'time)
#+END_SRC
**** Capture Templates
- Todo template
  #+BEGIN_SRC emacs-lisp
    (setq org-capture-templates '(("t" "Todo"
                                          entry
                                          (file org-index-file)
                                          "* TODO %^{Todo} %^G \nDEADLINE: %^{Deadline}t \n:PROPERTIES:\n:CREATED: %U\n:END:\n\n%?")))
  #+END_SRC
- Idea template
  #+BEGIN_SRC emacs-lisp
    (add-to-list 'org-capture-templates '("i" "Idea"
                                          entry
                                          (file "ideas.org")
                                          "* TODO %^{Todo} %^G \n:PROPERTIES:\n:CREATED: %U\n:END:\n\n%?"))
  #+END_SRC
- Books template
  #+BEGIN_SRC emacs-lisp
    (add-to-list 'org-capture-templates '("b" "Books"
                                          table-line
                                          (file "books.org")
                                          "| %^{Title} | %^{Author} | %^{Category} | %^L |"))
  #+END_SRC
- Journal template
  #+BEGIN_SRC emacs-lisp
    (add-to-list 'org-capture-templates '("j" "Journal Entry"
                                          entry
                                          (file+olp+datetree "journal.org")
                                          "** %U %^{Title}\n%?"))
  #+END_SRC
- Project template
  #+BEGIN_SRC emacs-lisp
    (add-to-list 'org-capture-templates '("p" "Project"
                                          entry
                                          (file "projects.org")
                                          "* PROJECT %^{Title} %^G\n%?"))
  #+END_SRC
Set org-refile-targets to the agenda files
#+BEGIN_SRC emacs-lisp
(setq org-refile-targets '((org-agenda-files :maxlevel . 1)))
#+END_SRC
**** Keybindings
Some basic keybindings
#+BEGIN_SRC emacs-lisp
  (define-key global-map "\C-cl" 'org-store-link)
  (define-key global-map "\C-ca" 'org-agenda)
  (define-key global-map "\C-cc" 'org-capture)
#+END_SRC
Hitting =C-c C-x C-s= should mark my todo as done and move it to =archive.org=
#+BEGIN_SRC emacs-lisp
(define-key org-mode-map (kbd "C-c C-x C-s") 'done-and-dusted)
#+END_SRC
I want to open my index file using =C-c i=
#+BEGIN_SRC emacs-lisp
(defun fiddler/open-index ()
  "Open the master org TODO list."
  (interactive)
  (find-file org-index-file)
  (end-of-buffer))
(global-set-key (kbd "C-c i") 'fiddler/open-index)
#+END_SRC
I want to open the books database using =C-c b=
#+BEGIN_SRC emacs-lisp
(defun fiddler/open-book ()
  "Open the books database."
  (interactive)
  (find-file "~/org/books.org")
  (end-of-buffer))
(global-set-key (kbd "C-c b") 'fiddler/open-book)
#+END_SRC
I want to open my journal using =C-c j=
#+BEGIN_SRC emacs-lisp
(defun fiddler/open-journal ()
  "Open the master org TODO list."
  (interactive)
  (find-file "~/org/journal.org")
  (end-of-buffer))
(global-set-key (kbd "C-c j") 'fiddler/open-journal)
#+END_SRC
*** Notes and Org-Drill
I want to be able to learn from my notes, that is, I want to Emacs to drill my notes so that I can learn
First I need to setup a method to generate the note filename on the fly.
#+BEGIN_SRC emacs-lisp
(defun fiddler/generate-note ()
  "Generate a note in the notes directory"
  (setq note-name (read-string "File: "))
  (expand-file-name (format "%s.org" note-name) "~/org/notes/"))
#+END_SRC
After this I need to generate the template that has to be inserted
#+BEGIN_SRC emacs-lisp
(defun fiddler/generate-note-template ()
  "Generate the template for the note without the timestamp"
  (concat (format "#+TITLE: %s" note-name) "\n#+AUTHOR: Anirudh C\n" (format "\n* %s" note-name)))
#+END_SRC
Notes template
#+BEGIN_SRC emacs-lisp
(add-to-list 'org-capture-templates '("n" "Notes"
                                       plain
                                       (file fiddler/generate-note)
                                       ;; Add timestamp
                                       "%(concat (fiddler/generate-note-template) \"\n:PROPERTIES:\n:CREATED: %U\n:END:\n\n%?\")"))
#+END_SRC
=org-drill= to learn easily
#+BEGIN_SRC emacs-lisp
(use-package org-drill
  :defer t
  :ensure org-plus-contrib
  :commands (org-drill)
  :init (require 'cl)
  :config
  (setq org-drill-use-visible-cloze-face-p t)
  (setq org-drill-hide-item-headings-p t))
#+END_SRC
*** Habits
Install =org-habit=
#+BEGIN_SRC emacs-lisp
(add-to-list 'org-modules 'org-habit)
(require 'org-habit)
#+END_SRC
Template for capturing habits
#+BEGIN_SRC emacs-lisp
;; Generate the scheduled timestamp
(defun fiddler/gen-habit-timestamp ()
  (org-insert-time-stamp (org-read-date nil t) t nil nil nil " .+1d"))
;; Generate the properties for the habit
(defun fiddler/gen-habit-props ()
  '"\n:PROPERTIES:\n:LOGGING: DONE(!) logrepeat\n:STYLE: habit\n:END:\n")
(add-to-list 'org-capture-templates '("h" "Habit"
                                      entry
                                      (file+headline org-index-file "Habits")
                                      "** TODO %^{Title} \nSCHEDULED: %(fiddler/gen-habit-timestamp) %(fiddler/gen-habit-props) %?"))
#+END_SRC
*** Export
Allow =babel= to evaluate emacs lisp, python, C, C++ and gnuplot code
#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (python . t)
   (C . t)
   (gnuplot . t)))
#+END_SRC
Make =babel= evaluate code blocks without confirmation
#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+END_SRC
Remove the footer in HTML exports
#+BEGIN_SRC emacs-lisp
(setq org-html-postamble nil)
#+END_SRC
Open the exported HTML files in FireFox
#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "firefox")
(setenv "BROWSER" "firefox")
#+END_SRC
Make all code blocks syntax highlighted
#+BEGIN_SRC emacs-lisp
(setq org-latex-listings 'minted
      org-latex-packages-alist '(("" "minted"))
      org-latex-pdf-process
      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC
*** Help
I have a file on my orgfiles which is a document on the keybindings in org. I want to open it quickly.
#+BEGIN_SRC emacs-lisp
(defun fiddler/open-org-help ()
  "Open my org mode help file"
  (interactive)
  (find-file "~/org/org-cheat-sheet.org")
  (end-of-buffer))
(global-set-key (kbd "C-c h") 'fiddler/open-org-help)
#+END_SRC
** Completion
I use =company= for an inline completion
#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :defer t
  :init
  (global-company-mode)
  :config
  (setq company-idle-delay 0.4)
  (setq company-selection-wrap-around t)
  (define-key company-active-map (kbd "jk") 'company-abort)
  (define-key company-active-map (kbd "C-n") 'company-select-next)
  (define-key company-active-map (kbd "C-p") 'company-select-previous))
#+END_SRC
** Config Sugar
Make all prompts y or n instead of yes or no
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
Open my config quickly
#+BEGIN_SRC emacs-lisp
(defun fiddler/open-config ()
  "Open the config file"
  (interactive)
  (find-file "~/.emacs.d/config.org")
  (end-of-buffer))
(global-set-key (kbd "C-c e") 'fiddler/open-config)
#+END_SRC
Refresh the configuration inplace without restarting emacs
#+BEGIN_SRC emacs-lisp
(defun fiddler/reload-config ()
  "Reload config on the fly without restarting emacs"
  (interactive)
  (load-file "~/.emacs.d/init.el")
  (message "Reloaded Config"))
#+END_SRC
